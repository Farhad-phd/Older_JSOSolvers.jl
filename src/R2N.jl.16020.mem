        - using LinearAlgebra
        - using LinearOperators
        - export R2N, R2NSolver
        - export ShiftedLBFGSSolver
        - #TODO check isa(nlp, LSR1Model) and updated op
        - 
        - # const R2N_allowed_subsolvers = [CglsSolver, CrlsSolver, LsqrSolver, LsmrSolver, minres]
        - 
        - #TODO do I export ShiftedLBFGSSolver? in seprate file
        - # NOTES: the memeory can be define in LBFGSModels by using mem = 5
        - 
        - # const R2N_allowed_subsolvers = [CgLanczosShiftSolver, MinaresSolver, ShiftedLBFGSSolver]
        - 
        - 
        - abstract type AbstractShiftedLBFGSSolver end
        - 
        - struct ShiftedLBFGSSolver <: AbstractShiftedLBFGSSolver
        -   # Shifted LBFGS-specific fields
        - end
        - 
        - """
        -     R2N(nlp; kwargs...)
        - 
        - A first-order quadratic regularization method for unconstrained optimization.
        - 
        - For advanced usage, first define a `R2NSolver` to preallocate the memory used in the algorithm, and then call `solve!`:
        - 
        -     solver = R2NSolver(nlp)
        -     solve!(solver, nlp; kwargs...)
        - 
        - # Arguments
        - - `nlp::AbstractNLPModel{T, V}` is the model to solve, see `NLPModels.jl`.
        - 
        - # Keyword arguments 
        - - `x::V = nlp.meta.x0`: the initial guess.
        - - `atol::T = √eps(T)`: absolute tolerance.
        - - `rtol::T = √eps(T)`: relative tolerance: algorithm stops when ‖∇f(xᵏ)‖ ≤ atol + rtol * ‖∇f(x⁰)‖.
        - - `η1 = eps(T)^(1/4)`, `η2 = T(0.95)`: step acceptance parameters.
        - - `γ1 = T(1/2)`, `γ2 = 1/γ1`: regularization update parameters.
        - - `σmin = eps(T)`: step parameter for R2N algorithm.
        - - `max_eval::Int = -1`: maximum number of evaluation of the objective function.
        - - `max_time::Float64 = 30.0`: maximum time limit in seconds.
        - - `max_iter::Int = typemax(Int)`: maximum number of iterations.
        - - `β = T(0) ∈ [0,1]` is the constant in the momentum term. If `β == 0`, R2N does not use momentum.
        - - `verbose::Int = 0`: if > 0, display iteration details every `verbose` iteration.
        - - `subsolver_type::Union{Type{<:KrylovSolver}, Type{ShiftedLBFGSSolver}} = ShiftedLBFGSSolver`: the subsolver to solve the shifted system. Default is `JSOSolvers.ShiftedLBFGSSolver` which is the exact solver.
        - - `subsolver_verbose::Int = 0`: if > 0, display iteration information every `subsolver_verbose` iteration of the subsolver if CG is selected.
        - 
        - # Output
        - The value returned is a `GenericExecutionStats`, see `SolverCore.jl`.
        - 
        - # Callback
        - The callback is called at each iteration.
        - The expected signature of the callback is `callback(nlp, solver, stats)`, and its output is ignored.
        - Changing any of the input arguments will affect the subsequent iterations.
        - In particular, setting `stats.status = :user` will stop the algorithm.
        - All relevant information should be available in `nlp` and `solver`.
        - Notably, you can access, and modify, the following:
        - - `solver.x`: current iterate;
        - - `solver.gx`: current gradient;
        - - `stats`: structure holding the output of the algorithm (`GenericExecutionStats`), which contains, among other things:
        -   - `stats.dual_feas`: norm of current gradient;
        -   - `stats.iter`: current iteration counter;
        -   - `stats.objective`: current objective function value;
        -   - `stats.status`: current status of the algorithm. Should be `:unknown` unless the algorithm has attained a stopping criterion. Changing this to anything will stop the algorithm, but you should use `:user` to properly indicate the intention.
        -   - `stats.elapsed_time`: elapsed time in seconds.
        - 
        - # Examples
        - ```jldoctest
        - using JSOSolvers, ADNLPModels
        - nlp = ADNLPModel(x -> sum(x.^2), ones(3))
        - stats = R2N(nlp)
        - 
        - # output
        - 
        - "Execution stats: first-order stationary"
        - ```
        - 
        - ```jldoctest
        - using JSOSolvers, ADNLPModels
        - nlp = ADNLPModel(x -> sum(x.^2), ones(3))
        - solver = R2NSolver(nlp);
        - stats = solve!(solver, nlp)
        - 
        - # output
        - 
        - "Execution stats: first-order stationary"
        - ```
        - """
        - mutable struct R2NSolver{
        -   T,
        -   V,
        -   Op <: AbstractLinearOperator{T},
        -   Op2 <: AbstractLinearOperator{T},
        -   Sub <: Union{KrylovSolver{T, T, V}, ShiftedLBFGSSolver},
        - } <: AbstractOptimizationSolver
        -   x::V
        -   cx::V
        -   gx::V
        -   gn::V
        -   σ::T
        -   H::Op
        -   shifted_H::Op2
        -   Hs::V
        -   s::V
        -   obj_vec::V # used for non-monotone behaviour
        -   subsolver_type::Sub
        -   cgtol::T
        - end
        - 
      320 function R2NSolver(
        -   nlp::AbstractNLPModel{T, V};
        -   non_mono_size = 1,
        -   subsolver_type::Union{Type{<:KrylovSolver}, Type{ShiftedLBFGSSolver}} = MinresSolver,
        - ) where {T, V}
        0   nvar = nlp.meta.nvar
       80   x = V(undef, nvar) # vs similar(nlp.meta.x0)
       80   cx = V(undef, nvar)
       80   gx = V(undef, nvar)
       80   gn = isa(nlp, QuasiNewtonModel) ? V(undef, nvar) : V(undef, 0)
       80   Hs = V(undef, nvar)
        0   H = isa(nlp, QuasiNewtonModel) ? nlp.op : hess_op!(nlp, x, Hs)
      816   shifted_H = LinearOperator(Matrix{T}(I, nvar, nvar))
        -   Op = typeof(H)
        -   Op2 = typeof(shifted_H)
        -   σ = zero(T) # init it to zero for now 
       80   s = V(undef, nvar)
        -   cgtol = one(T) # must be ≤ 1.0
       64   obj_vec = fill(typemin(T), non_mono_size)
        -   subsolver =
        -     isa(subsolver_type, Type{ShiftedLBFGSSolver}) ? subsolver_type() : subsolver_type(nvar, nvar, V)
        - 
        -   Sub = typeof(subsolver)
       96   return R2NSolver{T, V, Op,Op2, Sub}(x, cx, gx, gn, σ, H,shifted_H, Hs, s, obj_vec, subsolver, cgtol)
        - end
        - 
        - function SolverCore.reset!(solver::R2NSolver{T}) where {T}
        -   fill!(solver.obj_vec, typemin(T))
        -   solver
        - end
        - function SolverCore.reset!(solver::R2NSolver{T}, nlp::AbstractNLPModel) where {T}
        -   fill!(solver.obj_vec, typemin(T))
        -   @assert (length(solver.gn) == 0) || isa(nlp, QuasiNewtonModel)
        -   solver.H = isa(nlp, QuasiNewtonModel) ? nlp.op : hess_op!(nlp, x, Hs)
        -   solver.shifted_H = LinearOperator(Matrix{T}(I, nlp.meta.nvar, nlp.meta.nvar))
        -   solver.cgtol = one(T)
        -   solver
        - end
        - 
      192 @doc (@doc R2NSolver) function R2N(
        -   nlp::AbstractNLPModel{T, V};
        -   subsolver_type::Union{Type{<:KrylovSolver}, Type{ShiftedLBFGSSolver}} = MinresSolver,
        -   non_mono_size = 1,
        -   kwargs...,
        - ) where {T, V}
        0   solver = R2NSolver(nlp, non_mono_size = non_mono_size, subsolver_type = subsolver_type)
       16   return solve!(solver, nlp; non_mono_size = non_mono_size, kwargs...)
        - end
        - 
        - function SolverCore.solve!(
        -   solver::R2NSolver{T, V},
        -   nlp::AbstractNLPModel{T, V},
        -   stats::GenericExecutionStats{T, V};
        -   callback = (args...) -> nothing,
        -   x::V = nlp.meta.x0,
        -   atol::T = √eps(T),
        -   rtol::T = √eps(T),
        -   η1 = eps(T)^(1 / 4),
        -   η2 = T(0.95),
        -   γ1 = T(1 / 2),
        -   γ2 = 1 / γ1,
        -   σmin = zero(T),
        -   max_time::Float64 = 30.0,
        -   max_eval::Int = -1,
        -   max_iter::Int = typemax(Int),
        -   verbose::Int = 0,
        -   subsolver_verbose::Int = 0,
        -   non_mono_size = 1,
        - ) where {T, V}
        0   unconstrained(nlp) || error("R2N should only be called on unconstrained problems.")
        0   if non_mono_size < 1
        0     error("non_mono_size must be greater than or equal to 1")
        -   end
        0   if (solver.subsolver_type isa ShiftedLBFGSSolver && !isa(nlp, LBFGSModel))
        -     error("Unsupported subsolver type, ShiftedLBFGSSolver is only can be used by LBFGSModel")
        -   end
        -   #TODO make sure that we have a shifted solver for LSR1Model
        -   # if isa(nlp, LSR1Model)
        -   #   @info "only solver allowed is trunked CG for LSR1Model"
        -   #   solver.subsolver_type = CrSolver
        -   # end
        -   #TODO 
        -   # subsolver_type in R2N_allowed_subsolvers ||
        -   #   error("subproblem solver must be one of $(R2N_allowed_subsolvers)")
        0   reset!(stats)
        0   start_time = time()
        0   set_time!(stats, 0.0)
        - 
        0   n = nlp.meta.nvar
        0   x = solver.x .= x
        0   ck = solver.cx
        0   ∇fk = solver.gx # k-1
        0   ∇fn = solver.gn #current 
        0   s = solver.s
        0   H = solver.H
        -   shifted_H = solver.shifted_H
        0   Hs = solver.Hs
        -   σk = solver.σ
        0   cgtol = solver.cgtol
        - 
        0   set_iter!(stats, 0)
        0   set_objective!(stats, obj(nlp, x))
        - 
        0   grad!(nlp, x, ∇fk)
        0   isa(nlp, QuasiNewtonModel) && (∇fn .= ∇fk)
        0   norm_∇fk = norm(∇fk)
        0   set_dual_residual!(stats, norm_∇fk)
        - 
        0   σk = 2^round(log2(norm_∇fk + 1))
        - 
        -   # Stopping criterion: 
        0   ϵ = atol + rtol * norm_∇fk
        0   optimal = norm_∇fk ≤ ϵ
        0   if optimal
        0     @info("Optimal point found at initial point")
        0     @info @sprintf "%5s  %9s  %7s  %7s " "iter" "f" "‖∇f‖" "σ"
        0     @info @sprintf "%5d  %9.2e  %7.1e  %7.1e" stats.iter stats.objective norm_∇fk σk
        -   end
        0   if verbose > 0 && mod(stats.iter, verbose) == 0
        0     @info @sprintf "%5s  %9s  %7s  %7s " "iter" "f" "‖∇f‖" "σ"
        0     infoline = @sprintf "%5d  %9.2e  %7.1e  %7.1e" stats.iter stats.objective norm_∇fk σk
        -   end
        - 
        0   set_status!(
        -     stats,
        -     get_status(
        -       nlp,
        -       elapsed_time = stats.elapsed_time,
        -       optimal = optimal,
        -       max_eval = max_eval,
        -       iter = stats.iter,
        -       max_iter = max_iter,
        -       max_time = max_time,
        -     ),
        -   )
        - 
        0   solver.σ = σk #TODO do I meed this 
        -   callback(nlp, solver, stats)
        0   σk = solver.σ
        - 
        0   done = stats.status != :unknown
        0   cgtol = max(rtol, min(T(0.1), √norm_∇fk, T(0.9) * cgtol))
        - 
        0   while !done
        0     ∇fk .*= -1
        0     subsolve!(solver, s, ∇fk, 0.0, cgtol, n, subsolver_verbose)
        0     slope = dot(n, s, ∇fk) # = -dot(s, ∇fk) but ∇fk is negative
        0     mul!(Hs, H, s)
        0     curv = dot(s, Hs)
        0     ΔTk = (slope + curv) / 2  # since ∇fk is negative, otherwise we had -dot(s, ∇fk)
        -     # ΔTk = (dot(s, ∇fk) + σk * dot(s, s)) / 2  # since ∇fk is negative, otherwise we had -dot(s, ∇fk)
        - 
        0     ck .= x .+ s
        -     # ck .+= s
        0     fck = obj(nlp, ck)
        0     if fck == -Inf
        0       set_status!(stats, :unbounded)
        -       break
        -     end
        - 
        0     if non_mono_size > 1  #non-monotone behaviour
        0       k = mod(stats.iter, non_mono_size) + 1
        0       solver.obj_vec[k] = stats.objective
        0       fck_max = maximum(solver.obj_vec)
        0       ρk = (fck_max - fck) / (fck_max - fck + ΔTk)
        -     else
     1216       ρk = (stats.objective - fck) / ΔTk
        -     end
        - 
        -     # Update regularization parameters
      304     if ρk >= η2
        0       σk = max(σmin, γ1 * σk)
      240     elseif ρk < η1
        0       σk = σk * γ2
        -     end
        - 
        -     # Acceptance of the new candidate
      304     if ρk >= η1
        0       x .= ck
        0       grad!(nlp, x, ∇fk)
        0       if isa(nlp, QuasiNewtonModel)
        0         ∇fn .-= ∇fk
        0         ∇fn .*= -1  # = ∇f(xₖ₊₁) - ∇f(xₖ)
        0         push!(nlp, s, ∇fn)
        0         ∇fn .= ∇fk
        -       end
        0       set_objective!(stats, fck)
        0       norm_∇fk = norm(∇fk)
        -     end
        - 
        0     set_iter!(stats, stats.iter + 1)
        0     set_time!(stats, time() - start_time)
        0     set_dual_residual!(stats, norm_∇fk)
        0     optimal = norm_∇fk ≤ ϵ
        - 
        0     if verbose > 0 && mod(stats.iter, verbose) == 0
        0       @info infoline
        0       infoline = @sprintf "%5d  %9.2e  %7.1e  %7.1e" stats.iter stats.objective norm_∇fk σk
        -     end
        - 
        0     set_status!(
        -       stats,
        -       get_status(
        -         nlp,
        -         elapsed_time = stats.elapsed_time,
        -         optimal = optimal,
        -         max_eval = max_eval,
        -         iter = stats.iter,
        -         max_iter = max_iter,
        -         max_time = max_time,
        -       ),
        -     )
        0     solver.σ = σk
        0     cgtol = max(rtol, min(T(0.1), √norm_∇fk, T(0.9) * cgtol)) 
        -     callback(nlp, solver, stats) # cgtol needs to be updated in callback
        0     σk = solver.σ
        0     done = stats.status != :unknown
        -   end
        - 
        0   set_solution!(stats, x)
        0   return stats
        - end
        - 
        - function subsolve!(R2N::R2NSolver, s, ∇f, atol, cgtol, n, subsolver_verbose)  
        -   if R2N.subsolver_type isa MinresSolver
        -     minres!(
        -       R2N.subsolver_type,
        -       R2N.H, #A
        -       ∇f, #b 
        -       λ = R2N.σ,
        -       itmax = 2*n,
        -       verbose = subsolver_verbose,
        -     )
        -     s .= R2N.subsolver_type.x
        -     # stas = R2N.subsolver_type.stats
        -   elseif R2N.subsolver_type isa KrylovSolver
        -     Krylov.solve!(
        -       R2N.subsolver_type,
        -       (R2N.H + R2N.σ * R2N.shifted_H),
        -       ∇f,
        -       atol = atol,
        -       rtol = cgtol,
        -       itmax = 2*n,
        -       verbose = subsolver_verbose,
        -     )
        -     s .= R2N.subsolver_type.x
        -     # stas = R2N.subsolver_type.stats
        - 
        -   elseif R2N.subsolver_type isa ShiftedLBFGSSolver
        -     solve_shifted_system!(s, R2N.H, ∇f, R2N.σ)
        -   else
        -     error("Unsupported subsolver type")
        -   end
        - end
        - 
        - 
        - # function subsolve!(R2N::R2NSolver, s, H, ∇f, atol, cgtol, n, σ, subsolver_verbose)
        - #   if R2N.subsolver_type isa KrylovSolver
        - #     # Define a shifted operator that applies H + σ * I(n) without allocating
        - #     shifted_op = LinearOperator(size(H),
        - #         (v_in, v_out) -> begin
        - #             mul!(v_out, H, v_in)       # v_out = H * v_in
        - #             v_out .+= σ * v_in         # v_out += σ * v_in
        - #         end
        - #     )
        - #     Krylov.solve!(
        - #         R2N.subsolver_type,
        - #         shifted_op,
        - #         ∇f,
        - #         atol = atol,
        - #         rtol = cgtol,
        - #         itmax = 2*n,
        - #         verbose = subsolver_verbose,
        - #     )
        - #     s .= R2N.subsolver_type.x
        - #   elseif R2N.subsolver_type isa MinresSolver
        - #     # Use the shift parameter λ = σ to avoid allocation in minres!
        - #     minres!(
        - #         R2N.subsolver_type,
        - #         H, # A
        - #         ∇f, # b
        - #         λ = σ,
        - #         itmax = 2*n,
        - #         verbose = subsolver_verbose,
        - #     )
        - #     s .= R2N.subsolver_type.x
        - #   elseif R2N.subsolver_type isa ShiftedLBFGSSolver
        - #     solve_shifted_system!(s, H, ∇f, σ)
        - #   else
        - #     error("Unsupported subsolver type")
        - #   end
        - # end
